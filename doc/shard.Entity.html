<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>API docs for &ldquo;shard.Entity&rdquo;</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
    
    
  </head>
  <body>
    <h1 class="class">Class s.Entity(<span title="shard.eventprocessor.EventProcessor">shard.eventprocessor.EventProcessor</span>):</h1>
    <p>
      <span id="part">Part of <a href="shard.html">shard</a></span>
      
      <a href="classIndex.html#shard.Entity">View In Hierarchy</a>
    </p>
    <div>
      
    </div>
    <pre>An Entity is a Shard game object.
This is the base class for the player, NPCs and items.
An Entity holds information used by the Shard game logic:

Entity.entity_type
    One of shard.PLAYER, shard.NPC, shard.ITEM_BLOCK or
    shard.ITEM_NOBLOCK.

Entity.identifier
    Must be an object whose string representation yields an unique
    identification.

Entity.asset_desc
    Preferably a string with a file name or an URI of a media file
    containing the data for visualizing the Entity.

Entity.asset
    The actual asset, application-dependent. The UserInterface may fetch
    the asset using Entity.asset_desc and attach it here.

Entity.state
    The state the Entity is in. Defaults to None.

In addition,

Entity.user_interface

is added by and points to the UserInterface instance.

A Shard Client should use subclasses (possibly with multiple inheritance)
or custom attachements to instances of this class to implement the game
objects used by the rendering engine (2D sprites, 3D models). Usually the
Client manages a list of Entity instances. Everything concernig the
actual graphical representation is done by the UserInterface. Since this
is very application dependent it is not covered in the base class. Check
the documentation and source of the UserInterface for further insight on
how it handles game objects.</pre>

    
    
    <div id="splitTables">
      <table class="children sortable" id="id86">
  
  
<tr class="method">
    
    
    <td>Method</td>
    <td><a href="shard.Entity.html#__init__">__init__</a></td>
    <td><tt>Initialise.</tt></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="shard.Entity.html#process_MovesToEvent">process_MovesToEvent</a></td>
    <td><tt>This method is called by the UserInterface.</tt></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="shard.Entity.html#process_ChangeStateEvent">process_ChangeStateEvent</a></td>
    <td><tt>This method is called by the UserInterface.</tt></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="shard.Entity.html#process_DropsEvent">process_DropsEvent</a></td>
    <td><tt>This method is called by the UserInterface.</tt></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="shard.Entity.html#process_PicksUpEvent">process_PicksUpEvent</a></td>
    <td><tt>This method is called by the UserInterface.</tt></td>
  </tr><tr class="method">
    
    
    <td>Method</td>
    <td><a href="shard.Entity.html#process_SaysEvent">process_SaysEvent</a></td>
    <td><tt>This method is called by the UserInterface.</tt></td>
  </tr>
  
</table>
      
      
    </div>
    
    
    

    <div class="function">
  <a name="shard.Entity.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, entity_type, identifier, asset_desc):
    
  </div>
  <div class="functionBody">
    
    <pre>Initialise.
This method sets up the following attributes from the values given:

Entity.entity_type
Entity.identifier
Entity.asset_desc
Entity.asset
Entity.state</pre>
  </div>
</div><div class="function">
  <a name="shard.Entity.process_MovesToEvent">
    
  </a>
  <a name="process_MovesToEvent">
    
  </a>
  <div class="functionHeader">
    
    def
    process_MovesToEvent(self, event):
    
  </div>
  <div class="functionBody">
    
    <pre>This method is called by the UserInterface.
The Entity representation has to execute the according action over
the course of Entity.action_frames frames. But it must du so in an
non-blocking fashion - this method must return as soon as possible.
So do set up counters or frame queues here. Your implementation may
call another method once per frame, do the actual work there.</pre>
  </div>
</div><div class="function">
  <a name="shard.Entity.process_ChangeStateEvent">
    
  </a>
  <a name="process_ChangeStateEvent">
    
  </a>
  <div class="functionHeader">
    
    def
    process_ChangeStateEvent(self, event):
    
  </div>
  <div class="functionBody">
    
    <pre>This method is called by the UserInterface.
The Entity representation has to execute the according action over
the course of Entity.action_frames frames. But it must du so in an
non-blocking fashion - this method must return as soon as possible.
So do set up counters or frame queues here. Your implementation may
call another method once per frame, do the actual work there.</pre>
  </div>
</div><div class="function">
  <a name="shard.Entity.process_DropsEvent">
    
  </a>
  <a name="process_DropsEvent">
    
  </a>
  <div class="functionHeader">
    
    def
    process_DropsEvent(self, event):
    
  </div>
  <div class="functionBody">
    
    <pre>This method is called by the UserInterface.
The Entity representation has to execute the according action over
the course of Entity.action_frames frames. But it must du so in an
non-blocking fashion - this method must return as soon as possible.
So do set up counters or frame queues here. Your implementation may
call another method once per frame, do the actual work there.</pre>
  </div>
</div><div class="function">
  <a name="shard.Entity.process_PicksUpEvent">
    
  </a>
  <a name="process_PicksUpEvent">
    
  </a>
  <div class="functionHeader">
    
    def
    process_PicksUpEvent(self, event):
    
  </div>
  <div class="functionBody">
    
    <pre>This method is called by the UserInterface.
The Entity representation has to execute the according action over
the course of Entity.action_frames frames. But it must du so in an
non-blocking fashion - this method must return as soon as possible.
So do set up counters or frame queues here. Your implementation may
call another method once per frame, do the actual work there.</pre>
  </div>
</div><div class="function">
  <a name="shard.Entity.process_SaysEvent">
    
  </a>
  <a name="process_SaysEvent">
    
  </a>
  <div class="functionHeader">
    
    def
    process_SaysEvent(self, event):
    
  </div>
  <div class="functionBody">
    
    <pre>This method is called by the UserInterface.
The Entity representation has to execute the according action over
the course of Entity.action_frames frames. But it must du so in an
non-blocking fashion - this method must return as soon as possible.
So do set up counters or frame queues here. Your implementation may
call another method once per frame, do the actual work there.</pre>
  </div>
</div>
    <address>
      <a href="index.html">API Documentation</a> for shard, generated by <a href="http://codespeak.net/~mwh/pydoctor/">pydoctor</a> at 2010-10-29 14:35:47.
    </address>
  </body>
</html>